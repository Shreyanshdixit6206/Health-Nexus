const express = require('express');
const bodyParser = require('body-parser');
const cors = require('cors');
const fs = require('fs');
const path = require('path');
const jwt = require('jsonwebtoken');
const session = require('express-session');
const multer = require('multer');
const { nanoid } = require('nanoid');

const DATA_DIR = path.join(__dirname, 'data');
const USERS_FILE = path.join(DATA_DIR, 'users.json');
const MEDS_FILE = path.join(DATA_DIR, 'medicines.json');
const ORDERS_FILE = path.join(DATA_DIR, 'orders.json');
const VAULT_FILE = path.join(DATA_DIR, 'vault.json');

const JWT_SECRET = process.env.JWT_SECRET || 'dev-secret-health-nexus';
const OTP_TTL_MS = 1000 * 60 * 5; // 5 minutes

const app = express();
app.use(cors());
app.use(bodyParser.json());

// Session support (simple memory store for prototype)
app.use(session({
  name: 'hn_sid',
  secret: process.env.SESSION_SECRET || 'dev-session-secret',
  resave: false,
  saveUninitialized: false,
  cookie: { maxAge: 1000 * 60 * 60 * 24 } // 1 day
}));

// Simple uploads via multer
const UPLOADS_DIR = path.join(__dirname, 'uploads');
if (!fs.existsSync(UPLOADS_DIR)) fs.mkdirSync(UPLOADS_DIR, { recursive: true });
const upload = multer({ dest: UPLOADS_DIR, limits: { fileSize: 5 * 1024 * 1024 } });

// In-memory OTP store: { aadhaar: { otp, expiresAt } }
const otps = {};

function readJson(file) {
  try {
    return JSON.parse(fs.readFileSync(file, 'utf8') || 'null') || [];
  } catch (e) {
    return [];
  }
}

function writeJson(file, obj) {
  fs.writeFileSync(file, JSON.stringify(obj, null, 2), 'utf8');
}

// Ensure data dir/files exist
if (!fs.existsSync(DATA_DIR)) fs.mkdirSync(DATA_DIR, { recursive: true });
if (!fs.existsSync(USERS_FILE)) writeJson(USERS_FILE, []);
if (!fs.existsSync(MEDS_FILE)) writeJson(MEDS_FILE, []);
if (!fs.existsSync(ORDERS_FILE)) writeJson(ORDERS_FILE, []);
if (!fs.existsSync(VAULT_FILE)) writeJson(VAULT_FILE, []);

// --- Auth helpers ---
function generateOtp() {
  return Math.floor(100000 + Math.random() * 900000).toString();
}

function authMiddleware(req, res, next) {
  // Prefer session-based auth
  if (req.session && req.session.user) {
    req.user = req.session.user;
    return next();
  }
  // fallback to token for backward compatibility
  const auth = req.headers.authorization;
  if (!auth || !auth.startsWith('Bearer ')) return res.status(401).json({ error: 'Missing token' });
  const token = auth.slice(7);
  try {
    const payload = jwt.verify(token, JWT_SECRET);
    req.user = payload;
    next();
  } catch (e) {
    return res.status(401).json({ error: 'Invalid token' });
  }
}

// --- Routes ---

app.post('/api/login-request', (req, res) => {
  const { aadhaar } = req.body || {};
  if (!aadhaar) return res.status(400).json({ error: 'aadhaar required' });
  const users = readJson(USERS_FILE);
  const user = users.find(u => u.aadhaar === aadhaar);
  if (!user) return res.status(404).json({ error: 'Aadhaar not found' });

  const otp = generateOtp();
  otps[aadhaar] = { otp, expiresAt: Date.now() + OTP_TTL_MS };
  console.log(`[DEV] OTP for ${aadhaar}: ${otp}`);

  // Return both devOtp and request token
  return res.json({ ok: true, devOtp: otp });
});

app.post('/api/verify-otp', (req, res) => {
  const { aadhaar, otp } = req.body || {};
  if (!aadhaar || !otp) return res.status(400).json({ error: 'aadhaar and otp required' });
  const record = otps[aadhaar];
  if (!record) return res.status(400).json({ error: 'No OTP requested for this aadhaar' });
  if (Date.now() > record.expiresAt) return res.status(400).json({ error: 'OTP expired' });
  if (record.otp !== String(otp)) return res.status(400).json({ error: 'Invalid OTP' });

  // OTP valid - issue token
  const users = readJson(USERS_FILE);
  const user = users.find(u => u.aadhaar === aadhaar);
  if (!user) return res.status(404).json({ error: 'User not found' });

  const token = jwt.sign({ id: user.id, name: user.name, aadhaar: user.aadhaar }, JWT_SECRET, { expiresIn: '7d' });

  // remove used otp
  delete otps[aadhaar];

  return res.json({ ok: true, token, user: { id: user.id, name: user.name, aadhaar: user.aadhaar } });
});

app.get('/api/medicines', (req, res) => {
  const q = (req.query.q || '').toLowerCase();
  const meds = readJson(MEDS_FILE) || [];
  if (!q) return res.json({ medicines: meds });
  const filtered = meds.filter(m => (m.name || '').toLowerCase().includes(q) || (m.company || '').toLowerCase().includes(q));
  return res.json({ medicines: filtered });
});

// Suggest generic substitutes based on name or synonyms
app.get('/api/search-suggest', (req, res) => {
  const q = (req.query.q || '').toLowerCase().trim();
  if (!q) return res.json({ results: [] });
  const meds = readJson(MEDS_FILE) || [];
  const results = meds.filter(m => {
    if ((m.name || '').toLowerCase().includes(q)) return true;
    if (m.synonyms && Array.isArray(m.synonyms)) {
      return m.synonyms.some(s => (s||'').toLowerCase().includes(q));
    }
    return false;
  }).slice(0, 12);
  return res.json({ results });
});

app.post('/api/orders', authMiddleware, (req, res) => {
  const order = req.body;
  if (!order || !order.items || !Array.isArray(order.items) || order.items.length === 0) {
    return res.status(400).json({ error: 'Invalid order' });
  }
  const orders = readJson(ORDERS_FILE);
  const newOrder = {
    id: nanoid(),
    userId: req.user.id,
    items: order.items,
    total: order.total || 0,
    address: order.address || null,
    customerName: order.customerName || req.user.name || 'Customer',
    customerPhone: order.customerPhone || null,
    paymentId: order.paymentId || null,
    paymentStatus: order.paymentStatus || 'pending',
    createdAt: new Date().toISOString()
  };
  orders.push(newOrder);
  writeJson(ORDERS_FILE, orders);
  return res.json({ ok: true, order: newOrder });
});

app.get('/api/orders', authMiddleware, (req, res) => {
  const orders = readJson(ORDERS_FILE) || [];
  const userOrders = orders.filter(o => o.userId === req.user.id);
  return res.json({ orders: userOrders });
});

// Vault - upload metadata and file
app.post('/api/vault', authMiddleware, upload.single('file'), (req, res) => {
  if (!req.file) return res.status(400).json({ error: 'file required' });
  const vault = readJson(VAULT_FILE) || [];
  const entry = {
    id: nanoid(),
    ownerId: req.user.id,
    filename: req.file.filename,
    originalname: req.file.originalname,
    mimetype: req.file.mimetype,
    size: req.file.size,
    createdAt: new Date().toISOString()
  };
  vault.push(entry);
  writeJson(VAULT_FILE, vault);
  return res.json({ ok: true, doc: entry });
});

app.get('/api/vault', authMiddleware, (req, res) => {
  const vault = readJson(VAULT_FILE) || [];
  const mine = vault.filter(v => v.ownerId === req.user.id);
  return res.json({ docs: mine });
});

app.delete('/api/vault/:id', authMiddleware, (req, res) => {
  const id = req.params.id;
  const vault = readJson(VAULT_FILE) || [];
  const idx = vault.findIndex(v => v.id === id && v.ownerId === req.user.id);
  if (idx === -1) return res.status(404).json({ error: 'Not found' });
  const [removed] = vault.splice(idx, 1);
  writeJson(VAULT_FILE, vault);
  // remove file if exists
  const filePath = path.join(UPLOADS_DIR, removed.filename || '');
  if (fs.existsSync(filePath)) fs.unlinkSync(filePath);
  return res.json({ ok: true });
});

// Serve frontend static files
const FRONTEND_DIR = path.join(__dirname, '..', 'frontend');
if (fs.existsSync(FRONTEND_DIR)) {
  app.use(express.static(FRONTEND_DIR));
}

const PORT = process.env.PORT || 3000;
const server = app.listen(PORT, () => {
  console.log(`Health NEXUS backend running on http://localhost:${PORT}`);
  console.log(`Data directory: ${DATA_DIR}`);
});

// Keep the process alive
setInterval(() => {}, 1000);

// Handle graceful shutdown
process.on('SIGINT', () => {
  console.log('\nShutting down...');
  process.exit(0);
});

process.on('SIGTERM', () => {
  process.exit(0);
});
